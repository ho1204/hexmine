<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ¡ê°í˜• ì§€ë¢°ì°¾ê¸° (ì¹¸ ì¡°ì ˆ ê°€ëŠ¥)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* ì‚¬ìš©ì ì •ì˜ CSS: ëª¨ë°”ì¼ ì„¸ë¡œ í™”ë©´ì— ìµœì í™” ë° í™”ë©´ ê°€ë“ ì±„ìš°ê¸° */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a202c; /* ë‹¤í¬ ëª¨ë“œ ë°°ê²½ */
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh; 
            margin: 0;
            padding: 0; 
            box-sizing: border-box;
            width: 100vw;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            border-radius: 0; 
            box-shadow: none; 
            padding: 1rem;
            width: 100%; 
            height: 100vh; 
            max-width: 500px; /* ì„¸ë¡œ í™”ë©´ ìµœëŒ€ ë„ˆë¹„ ì œí•œ */
            overflow: hidden; 
        }
        
        #game-area {
            width: 100%;
            flex-grow: 1; /* ë‚¨ì€ ìˆ˜ì§ ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ */
            display: flex;
            justify-content: center;
            align-items: center;
            padding-bottom: 5px;
            overflow: hidden; 
        }

        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0.75rem;
            padding: 0 0.25rem;
            flex-wrap: nowrap; 
            gap: 0.5rem; /* ë²„íŠ¼ê³¼ ë©”ì‹œì§€ ë°•ìŠ¤ ì‚¬ì´ì˜ ê°„ê²© */
        }

        #message-box {
            background-color: #4a5568;
            color: #edf2f7;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            /* ë©”ì‹œì§€ ë°•ìŠ¤ê°€ ë‚¨ì€ ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€í•˜ë„ë¡ ì„¤ì • */
            flex: 1 1 0%; 
            min-width: 0; 
        }
        
        #game-canvas {
            background-color: #1a202c; 
            border-radius: 0.5rem;
            touch-action: none; 
            cursor: pointer;
            max-width: 100%;
            max-height: 100%;
            display: block; 
        }

        .btn-action {
            padding: 0.75rem 1.5rem;
            background-color: #48bb78; 
            color: white;
            border-radius: 0.75rem;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn-action:hover {
            background-color: #38a169;
        }
        
        .btn-action:active {
            transform: scale(0.98);
        }

        .mono-font {
            font-family: 'Roboto Mono', monospace;
        }

        .flag-toggle-btn {
            background-color: #63b3ed;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
            /* ë²„íŠ¼ì˜ ë„ˆë¹„ë¥¼ ê°€ì¥ ê¸´ í…ìŠ¤íŠ¸ì— ë§ì¶° ê³ ì • */
            flex: 0 0 170px;
            min-width: 170px;
            text-wrap: nowrap; 
        }
        .flag-toggle-btn:hover {
            background-color: #4299e1;
        }
        .flag-toggle-btn.active {
            background-color: #e53e3e;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 class="text-2xl font-bold mb-3 text-white">Hex ì§€ë¢°ì°¾ê¸° (ì¹¸ ì¡°ì ˆ ê°€ëŠ¥)</h1>
        
        <div id="controls">
            <div id="message-box" class="mono-font">ì§€ë¢° 55ê°œ</div>
            <button id="flag-toggle" class="flag-toggle-btn">
                ğŸš© ì¼ë°˜ ëª¨ë“œ
            </button>
        </div>
        
        <div id="game-area">
            <canvas id="game-canvas"></canvas>
        </div>

        <button id="reset-button" class="btn-action w-full mt-3">
            ìƒˆ ê²Œì„ ì‹œì‘
        </button>
        <button id="adjust-button" class="btn-action w-full mt-2 bg-yellow-600 hover:bg-yellow-700">
            ì¹¸ ì¡°ì ˆ í•˜ê¸°
        </button>
        
        <p class="text-xs text-gray-400 mt-2">
            **ëª¨ë°”ì¼:** í„°ì¹˜í•˜ì—¬ ì—´ê¸°/ê¹ƒë°œ ê½‚ê¸° (ëª¨ë“œ ì „í™˜).
        </p>
    </div>

    <!-- Config Modal -->
    <div id="config-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-gray-700 p-6 rounded-xl shadow-2xl w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 text-white">ê²Œì„ í¬ê¸° ì¡°ì ˆ</h3>
            <p id="config-error" class="text-sm text-red-400 mb-3 hidden">ìœ íš¨í•œ ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš” (5~50).</p>
            <p class="text-sm text-gray-300 mb-3">ì§€ë¢° ê°¯ìˆ˜ëŠ” ì „ì²´ ì¹¸ì˜ 22%ë¡œ ìë™ ê³„ì‚°ë©ë‹ˆë‹¤.</p>
            <div class="space-y-4">
                <div>
                    <label for="input-rows" class="block text-sm font-medium text-gray-300">ì„¸ë¡œ ì¹¸ ìˆ˜ (Rows)</label>
                    <input type="number" id="input-rows" min="5" max="50" value="18" 
                           class="mt-1 block w-full rounded-lg border-gray-600 bg-gray-800 text-white p-2.5 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="input-cols" class="block text-sm font-medium text-gray-300">ê°€ë¡œ ì¹¸ ìˆ˜ (Cols)</label>
                    <input type="number" id="input-cols" min="5" max="50" value="14" 
                           class="mt-1 block w-full rounded-lg border-gray-600 bg-gray-800 text-white p-2.5 focus:ring-blue-500 focus:border-blue-500">
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="cancel-config" class="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-600 rounded-lg hover:bg-gray-500">ì·¨ì†Œ</button>
                <button id="save-config" class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700">ì ìš©í•˜ê³  ìƒˆ ê²Œì„ ì‹œì‘</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const resetButton = document.getElementById('reset-button');
            const adjustButton = document.getElementById('adjust-button');
            const messageBox = document.getElementById('message-box');
            const flagToggleButton = document.getElementById('flag-toggle');
            const gameArea = document.getElementById('game-area');
            
            // --- Config Modal Elements ---
            const configModal = document.getElementById('config-modal');
            const inputRows = document.getElementById('input-rows');
            const inputCols = document.getElementById('input-cols');
            const cancelConfigButton = document.getElementById('cancel-config');
            const saveConfigButton = document.getElementById('save-config');
            const configError = document.getElementById('config-error');

            // --- ê²Œì„ ì„¤ì • (ë™ì  ë³€ìˆ˜) ---
            let ROWS = 18; // ì„¸ë¡œ 18ì¹¸ (ê¸°ë³¸ê°’)
            let COLS = 14; // ê°€ë¡œ 14ì¹¸ (ê¸°ë³¸ê°’)
            const MINE_PERCENTAGE = 0.22;
            let MINE_COUNT = Math.max(1, Math.floor(ROWS * COLS * MINE_PERCENTAGE)); // ì§€ë¢° ê°¯ìˆ˜ (22%ë¡œ ìë™ ê³„ì‚°)
            const MARGIN = 4; 
            
            // --- ë™ì  í¬ê¸° ë³€ìˆ˜ ---
            let HEX_SIZE = 20; 

            // --- ê²Œì„ ìƒíƒœ ---
            let board = [];
            let isGameOver = false;
            let isFirstClick = true;
            let flagsRemaining = MINE_COUNT;
            let isFlagMode = false; 
            
            // --- ìƒ‰ìƒ ì •ì˜ ---
            const COLORS = {
                BACKGROUND: '#1a202c',
                UNREVEALED: '#4a5568', 
                REVEALED: '#2d3748', 
                BORDER: '#1a202c', 
                MINE: '#e53e3e', 
                FLAG: '#63b3ed', 
                TEXT: '#edf2f7',
                NUMBERS: [
                    'transparent', '#63b3ed', '#48bb78', '#fc8181', '#a3bffa', '#ecc94b', '#f6ad55', '#e53e3e', '#718096'
                ]
            };

            // --- í—¬í¼ í•¨ìˆ˜ ---

            const getHexagonPoints = (center_x, center_y, size) => {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle_deg = 30 + 60 * i;
                    const angle_rad = Math.PI / 180 * angle_deg;
                    points.push({
                        x: center_x + size * Math.cos(angle_rad),
                        y: center_y + size * Math.sin(angle_rad)
                    });
                }
                return points;
            };

            const hexToPixel = (row, col) => {
                const w = Math.sqrt(3) * HEX_SIZE; 
                const h = 2 * HEX_SIZE; 
                
                let x = w * (col + 0.5 * (row % 2));
                let y = h * 0.75 * row;

                return {
                    x: x + w / 2 + MARGIN,
                    y: y + HEX_SIZE + MARGIN 
                };
            };
            
            const pixelToHex = (px, py) => {
                px -= MARGIN;
                py -= MARGIN;
                
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                const h_step = h * 0.75; 

                let r_approx = Math.round((py - HEX_SIZE) / h_step);
                let x_adjusted = px - w / 2;
                if (r_approx % 2 === 1) {
                    x_adjusted -= w / 2;
                }
                let q_approx = Math.round(x_adjusted / w);
                
                let bestRow = -1, bestCol = -1;
                let minDistance = Infinity;

                for (let r = r_approx - 1; r <= r_approx + 1; r++) {
                    for (let c = q_approx - 1; c <= q_approx + 1; c++) {
                        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                            const center = hexToPixel(r, c);
                            const dx = (px + MARGIN) - center.x;
                            const dy = (py + MARGIN) - center.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < minDistance) {
                                minDistance = distance;
                                bestRow = r;
                                bestCol = c;
                            }
                        }
                    }
                }
                
                if (minDistance <= HEX_SIZE * 0.95 && bestRow !== -1) {
                    return { row: bestRow, col: bestCol };
                }

                return null;
            };

            const getNeighbors = (r, c) => {
                const neighbors = [];
                const isOddRow = r % 2 !== 0; 

                const offsets = [
                    [0, -1], [0, 1], 
                    [-1, 0], [1, 0],
                ];

                if (isOddRow) {
                    // í™€ìˆ˜ í–‰ì€ ì˜¤ë¥¸ìª½ ìœ„/ì•„ë˜ ì¶”ê°€
                    offsets.push([-1, 1], [1, 1]); 
                } else {
                    // ì§ìˆ˜ í–‰ì€ ì™¼ìª½ ìœ„/ì•„ë˜ ì¶”ê°€
                    offsets.push([-1, -1], [1, -1]); 
                }

                offsets.forEach(([dr, dc]) => {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        neighbors.push([nr, nc]);
                    }
                });
                return neighbors;
            };

            const initializeCanvasDimensions = () => {
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                
                const max_x = w * COLS + w / 2;
                const max_y = h * 0.75 * (ROWS - 1) + h;
                
                canvas.width = max_x + MARGIN * 2;
                canvas.height = max_y + MARGIN * 2;
            };

            // --- ê²Œì„ ë¡œì§ ---
            
            const createBoard = () => {
                board = Array.from({ length: ROWS }, (_, r) =>
                    Array.from({ length: COLS }, (_, c) => ({
                        row: r,
                        col: c,
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        mineCount: 0,
                    }))
                );
                flagsRemaining = MINE_COUNT;
                updateMessage();
                isGameOver = false;
                isFirstClick = true;
            };

            const placeMines = (startRow, startCol) => {
                let minesPlaced = 0;
                while (minesPlaced < MINE_COUNT) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);

                    const isStartCell = r === startRow && c === startCol;
                    const isNeighbor = getNeighbors(startRow, startCol).some(([nr, nc]) => nr === r && nc === c);

                    if (!board[r][c].isMine && !isStartCell && !isNeighbor) {
                        board[r][c].isMine = true;
                        minesPlaced++;
                    }
                }
                calculateMineCounts();
            };

            const calculateMineCounts = () => {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (!board[r][c].isMine) {
                            let count = 0;
                            getNeighbors(r, c).forEach(([nr, nc]) => {
                                if (board[nr]?.[nc]?.isMine) {
                                    count++;
                                }
                            });
                            board[r][c].mineCount = count;
                        }
                    }
                }
            };
            
            const revealCell = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS || board[r][c].isRevealed || board[r][c].isFlagged) {
                    return;
                }

                const cell = board[r][c];
                cell.isRevealed = true;

                if (cell.isMine) {
                    gameOver(false); 
                    return;
                }

                if (cell.mineCount === 0) {
                    getNeighbors(r, c).forEach(([nr, nc]) => {
                        if (board[nr] && board[nr][nc] && !board[nr][nc].isRevealed && !board[nr][nc].isFlagged) {
                            revealCell(nr, nc); 
                        }
                    });
                }
                
                checkWin();
            };

            const toggleFlag = (r, c) => {
                const cell = board[r][c];
                if (cell.isRevealed) return;

                if (cell.isFlagged) {
                    cell.isFlagged = false;
                    flagsRemaining++;
                } else if (flagsRemaining > 0) {
                    cell.isFlagged = true;
                    flagsRemaining--;
                }
                updateMessage();
                checkWin();
            };

            const checkWin = () => {
                let nonMineUnrevealedCount = 0;
                
                board.forEach(row => {
                    row.forEach(cell => {
                        if (!cell.isMine && !cell.isRevealed) {
                            nonMineUnrevealedCount++;
                        }
                    });
                });

                if (nonMineUnrevealedCount === 0 && !isGameOver) {
                     gameOver(true);
                }
            };
            
            const gameOver = (isWin) => {
                isGameOver = true;
                
                if (isWin) {
                    messageBox.textContent = "ğŸ¥³ ìŠ¹ë¦¬! ë‹¤ì‹œ í•˜ì‹œê² ì–´ìš”?";
                    messageBox.style.backgroundColor = '#48bb78'; 
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isFlagged = true;
                    }));
                } else {
                    messageBox.textContent = "ğŸ’¥ ê²Œì„ ì˜¤ë²„! ì§€ë¢° í­ë°œ!";
                    messageBox.style.backgroundColor = '#e53e3e'; 
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isRevealed = true;
                    }));
                }
                drawBoard();
            };

            const updateMessage = () => {
                if (!isGameOver) {
                    messageBox.textContent = `ğŸš© ${flagsRemaining}ê°œ ë‚¨ìŒ (ì´ ${MINE_COUNT}ê°œ)`;
                    messageBox.style.backgroundColor = '#4a5568';
                }
            };

            // ìë™ ì—´ê¸° (Chording) ê¸°ëŠ¥
            const autoRevealNeighbors = (r, c) => {
                const cell = board[r][c];
                if (!cell.isRevealed || cell.mineCount === 0) return;

                let flaggedCount = 0;
                let hasMineFlaggedIncorrectly = false; 
                const neighbors = getNeighbors(r, c);
                
                // ì¸ì ‘ ì…€ ì¤‘ ê¹ƒë°œ ê°¯ìˆ˜ ì¹´ìš´íŠ¸ ë° ì˜ëª» ê½‚ì€ ê¹ƒë°œ ì²´í¬
                neighbors.forEach(([nr, nc]) => {
                    const neighborCell = board[nr][nc];
                    if (neighborCell.isFlagged) {
                        flaggedCount++;
                        if (!neighborCell.isMine) {
                            hasMineFlaggedIncorrectly = true;
                        }
                    }
                });

                if (flaggedCount === cell.mineCount) {
                    // ê¹ƒë°œ ê°¯ìˆ˜ì™€ ì§€ë¢° ê°¯ìˆ˜ê°€ ì¼ì¹˜í•  ë•Œë§Œ ìë™ ì—´ê¸° ì‹œë„
                    neighbors.forEach(([nr, nc]) => {
                        const neighborCell = board[nr][nc];
                        // ê¹ƒë°œì´ ê½‚íˆì§€ ì•Šì•˜ê³ , ì•„ì§ ì—´ë¦¬ì§€ ì•Šì€ ì…€ë§Œ revealCell í˜¸ì¶œ
                        if (!neighborCell.isFlagged && !neighborCell.isRevealed) {
                            // ì˜ëª» ê½‚ì€ ê¹ƒë°œì´ ìˆë‹¤ë©´ ì´ ê³¼ì •ì—ì„œ ì§€ë¢°ê°€ í„°ì§
                            revealCell(nr, nc); 
                        }
                    });
                }
            };

            // --- ë Œë”ë§ ---

            const drawHexagon = (center_x, center_y, size, fill_color, border_color) => {
                const points = getHexagonPoints(center_x, center_y, size);
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();

                ctx.fillStyle = fill_color;
                ctx.fill();

                ctx.strokeStyle = border_color; 
                ctx.lineWidth = 1;
                ctx.stroke();
            };

            const drawBoard = () => {
                ctx.fillStyle = COLORS.BACKGROUND;
                ctx.fillRect(0, 0, canvas.width, canvas.height); 

                board.forEach(row => {
                    row.forEach(cell => {
                        const { x, y } = hexToPixel(cell.row, cell.col);
                        
                        let fillColor, contentColor, content = '';

                        if (cell.isRevealed) {
                            fillColor = COLORS.REVEALED;
                            contentColor = COLORS.TEXT;

                            if (cell.isMine) {
                                fillColor = COLORS.MINE;
                                content = 'ğŸ’£';
                            } else if (cell.mineCount > 0) {
                                content = cell.mineCount.toString();
                                contentColor = COLORS.NUMBERS[cell.mineCount];
                            } else {
                                fillColor = COLORS.REVEALED;
                            }
                        } else {
                            fillColor = COLORS.UNREVEALED;
                            
                            if (cell.isFlagged) {
                                content = 'ğŸš©';
                                contentColor = COLORS.FLAG;
                            }
                        }

                        drawHexagon(x, y, HEX_SIZE, fillColor, COLORS.BORDER);
                        
                        if (content) {
                            ctx.fillStyle = contentColor;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            if (content.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/)) {
                                // ì´ëª¨ì§€ ë Œë”ë§
                                ctx.font = `bold ${HEX_SIZE * 0.9}px Noto Sans KR`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            } else {
                                // ìˆ«ì ë Œë”ë§
                                ctx.font = `bold ${HEX_SIZE * 1.1}px Roboto Mono`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            }
                        }
                    });
                });
            };

            // --- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

            const handleCanvasClick = (event) => {
                if (event.type === 'contextmenu') {
                    event.preventDefault();
                    return;
                }
                
                if (isGameOver) return;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height; 
                const px = (event.clientX - rect.left) * scaleX;
                const py = (event.clientY - rect.top) * scaleY;
                
                const hex = pixelToHex(px, py);
                if (!hex) return;
                
                const { row, col } = hex;
                const cell = board[row][col]; 

                if (isFirstClick) {
                    placeMines(row, col);
                    isFirstClick = false;
                }

                const isRightClick = event.button === 2;
                const isLeftClick = event.button === 0;
                
                const isFlagAction = isRightClick || isFlagMode;

                // 1. Chording (ìë™ ì—´ê¸°) Logic: ì™¼ìª½ í´ë¦­ì´ë©°, ì´ë¯¸ ì—´ë¦° ìˆ«ì ì¹¸ì¼ ë•Œ ì‹¤í–‰ (ê¹ƒë°œ ëª¨ë“œì™€ ê´€ê³„ ì—†ìŒ)
                if (isLeftClick && cell.isRevealed && cell.mineCount > 0) {
                    autoRevealNeighbors(row, col);
                } 
                // 2. Primary Action (Flag/Reveal) Logic
                else if (isFlagAction) {
                    toggleFlag(row, col);
                } else if (isLeftClick) {
                    // ì¼ë°˜ Reveal (ê¹ƒë°œì´ ê½‚íŒ ì…€ì€ ê±´ë„ˆëœ€)
                    if (cell.isFlagged) {
                        return;
                    }
                    revealCell(row, col);
                }

                drawBoard();
            };
            
            // ê¹ƒë°œ ëª¨ë“œ í† ê¸€ ë²„íŠ¼
            flagToggleButton.addEventListener('click', () => {
                isFlagMode = !isFlagMode;
                flagToggleButton.textContent = isFlagMode ? "âŒ ê¹ƒë°œ ëª¨ë“œ í•´ì œ" : "ğŸš© ì¼ë°˜ ëª¨ë“œ";
                flagToggleButton.classList.toggle('active', isFlagMode);
                updateMessage();
            });

            // ìƒˆ ê²Œì„ ë²„íŠ¼
            resetButton.addEventListener('click', () => {
                isFlagMode = false;
                flagToggleButton.textContent = "ğŸš© ì¼ë°˜ ëª¨ë“œ";
                flagToggleButton.classList.remove('active');
                startGame();
            });
            
            // ì¹¸ ì¡°ì ˆ ë²„íŠ¼ (adjust-button)
            adjustButton.addEventListener('click', () => {
                // í˜„ì¬ ì„¤ì •ëœ ê°’ìœ¼ë¡œ ëª¨ë‹¬ ì´ˆê¸°í™”
                inputRows.value = ROWS;
                inputCols.value = COLS;
                configError.classList.add('hidden');
                configModal.classList.remove('hidden');
            });
            
            // ì¹¸ ì¡°ì ˆ ëª¨ë‹¬ - ì·¨ì†Œ
            cancelConfigButton.addEventListener('click', () => {
                configModal.classList.add('hidden');
            });
            
            // ì¹¸ ì¡°ì ˆ ëª¨ë‹¬ - ì €ì¥
            saveConfigButton.addEventListener('click', () => {
                configError.classList.add('hidden');
                const newRows = parseInt(inputRows.value);
                const newCols = parseInt(inputCols.value);
                
                // ìœ íš¨ì„± ê²€ì‚¬ (5 <= x <= 50)
                if (isNaN(newRows) || isNaN(newCols) || newRows < 5 || newCols < 5 || newRows > 50 || newCols > 50) {
                    configError.classList.remove('hidden');
                    return;
                }
                
                ROWS = newRows;
                COLS = newCols;
                MINE_COUNT = Math.max(1, Math.floor(ROWS * COLS * MINE_PERCENTAGE)); // ì§€ë¢° ìˆ˜ ì¬ê³„ì‚° (ìµœì†Œ 1ê°œ)
                
                configModal.classList.add('hidden');
                startGame();
            });

            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (PC)
            canvas.addEventListener('mousedown', handleCanvasClick);
            canvas.addEventListener('contextmenu', handleCanvasClick); 

            // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                handleCanvasClick({
                    clientX: e.touches[0].clientX,
                    clientY: e.touches[0].clientY,
                    target: e.target,
                    preventDefault: () => e.preventDefault(),
                    button: 0, 
                    type: 'mousedown'
                });
            });

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬ (í™”ë©´ ê°€ë“ ì±„ìš°ê¸° ë¡œì§)
            const resizeCanvas = () => {
                const w_factor = Math.sqrt(3);
                const h_step = 1.5;

                const boardWidthUnits = w_factor * COLS + w_factor / 2;
                const boardHeightUnits = h_step * (ROWS - 1) + 2; 

                const availableWidth = gameArea.clientWidth - MARGIN * 2;
                const availableHeight = gameArea.clientHeight - MARGIN * 2;
                
                if (availableWidth <= 0 || availableHeight <= 0) return;

                const hexSizeFromWidth = availableWidth / boardWidthUnits;
                const hexSizeFromHeight = availableHeight / boardHeightUnits;
                
                const newHexSize = Math.floor(Math.min(hexSizeFromWidth, hexSizeFromHeight) * 100) / 100;

                HEX_SIZE = Math.max(8, newHexSize);
                
                initializeCanvasDimensions();
                
                canvas.style.width = `${canvas.width}px`;
                canvas.style.height = `${canvas.height}px`; 

                drawBoard();
            };
            
            // --- ì‹œì‘ í•¨ìˆ˜ ---
            const startGame = () => {
                // MINE_COUNTë¥¼ í˜„ì¬ ROWS, COLSì— ë§ì¶° ì—…ë°ì´íŠ¸
                MINE_COUNT = Math.max(1, Math.floor(ROWS * COLS * MINE_PERCENTAGE));
                createBoard();
                resizeCanvas(); 
                updateMessage();
            };

            // ì´ˆê¸° ì‹œì‘ ë° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ì—°ê²°
            window.addEventListener('resize', resizeCanvas);
            
            // gameAreaì˜ í¬ê¸°ê°€ ê²°ì •ëœ í›„ resizeCanvasë¥¼ í˜¸ì¶œ
            window.onload = function() {
                setTimeout(startGame, 100);
            }
        });
    </script>
</body>
</html>