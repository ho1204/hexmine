<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ¡ê°í˜• ì§€ë¢°ì°¾ê¸° (í™”ë©´ ìµœì í™”)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* ì‚¬ìš©ì ì •ì˜ CSS: ê²Œì„ì˜ ì‹œê°ì  ìš”ì†Œë¥¼ ê°•ì¡°í•˜ê³  ëª¨ë°”ì¼ ì¹œí™”ì ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤. */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a202c; /* ë‹¤í¬ ëª¨ë“œ ë°°ê²½ */
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            /* ìµœì†Œ ë†’ì´ë¥¼ 100vhë¡œ ì„¤ì •í•˜ì—¬ ì„¸ë¡œ í™”ë©´ì„ ëª¨ë‘ ì±„ìš°ë„ë¡ í•¨ */
            min-height: 100vh; 
            margin: 0;
            padding: 10px; /* ì „ì²´ ì—¬ë°± ìµœì†Œí™” */
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            padding: 1rem;
            width: 100%; /* ëª¨ë°”ì¼ì—ì„œ ìµœëŒ€í•œ ë„“ê²Œ ì‚¬ìš© */
            max-width: 800px; /* ë°ìŠ¤í¬í†± ìµœëŒ€ í¬ê¸° ì œí•œ */
            max-height: 98vh; /* í™”ë©´ ë†’ì´ ì œí•œ */
            overflow: hidden; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }
        
        #game-area {
            width: 100%;
            overflow: auto; /* í•„ìš” ì‹œ ìŠ¤í¬ë¡¤ í—ˆìš© (ëª¨ë°”ì¼ ê°€ë¡œëª¨ë“œ ëŒ€ë¹„) */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            padding-bottom: 5px;
        }

        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0.75rem;
            padding: 0 0.25rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        #message-box {
            background-color: #4a5568;
            color: #edf2f7;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            flex-grow: 1;
            min-width: 100px;
        }
        
        #game-canvas {
            background-color: #1a202c; /* ë³´ë“œ ë°°ê²½ */
            border-radius: 0.5rem;
            touch-action: none; 
            cursor: pointer;
            /* CSS ë„ˆë¹„ë¥¼ 100%ë¡œ ì„¤ì •í•˜ê³ , JSì—ì„œ ë†’ì´ë¥¼ ì¢…íš¡ë¹„ì— ë§ì¶° ì¡°ì ˆ */
            width: 100%; 
            height: auto;
        }

        .btn-action {
            padding: 0.75rem 1.5rem;
            background-color: #48bb78; 
            color: white;
            border-radius: 0.75rem;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn-action:hover {
            background-color: #38a169;
        }
        
        .btn-action:active {
            transform: scale(0.98);
        }

        /* í°íŠ¸ ìŠ¤íƒ€ì¼: ì§€ë¢° ìˆ«ìì— ì‚¬ìš© */
        .mono-font {
            font-family: 'Roboto Mono', monospace;
        }

        .flag-toggle-btn {
            background-color: #63b3ed;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
            flex-grow: 1;
        }
        .flag-toggle-btn:hover {
            background-color: #4299e1;
        }
        .flag-toggle-btn.active {
            background-color: #e53e3e;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 class="text-2xl font-bold mb-3 text-white">Hex ì§€ë¢°ì°¾ê¸° (ìµœì í™”)</h1>
        
        <div id="controls">
            <div id="message-box" class="mono-font">ì§€ë¢° 70ê°œ</div>
            <button id="flag-toggle" class="flag-toggle-btn">
                ğŸš© ì¼ë°˜ ëª¨ë“œ
            </button>
        </div>
        
        <div id="game-area">
            <canvas id="game-canvas"></canvas>
        </div>

        <button id="reset-button" class="btn-action w-full mt-3">
            ìƒˆ ê²Œì„ ì‹œì‘
        </button>
        
        <p class="text-xs text-gray-400 mt-2">
            **ëª¨ë°”ì¼:** ì¼ë°˜ ëª¨ë“œì—ì„œ í„°ì¹˜í•˜ì—¬ ì—´ê¸°, ê¹ƒë°œ ëª¨ë“œì—ì„œ í„°ì¹˜í•˜ì—¬ ê¹ƒë°œ ê½‚ê¸°.
        </p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const resetButton = document.getElementById('reset-button');
            const messageBox = document.getElementById('message-box');
            const flagToggleButton = document.getElementById('flag-toggle');
            const gameContainer = document.getElementById('game-container');
            const gameArea = document.getElementById('game-area');
            
            // --- ê²Œì„ ì„¤ì • ---
            const ROWS = 20; // ì„¸ë¡œ 20ì¹¸
            const COLS = 24; // ê°€ë¡œ 24ì¹¸
            const MINE_COUNT = 70; 
            const MARGIN = 10; // ìº”ë²„ìŠ¤ ê°€ì¥ìë¦¬ ì—¬ë°±
            
            // --- ë™ì  í¬ê¸° ë³€ìˆ˜ ---
            let HEX_SIZE = 20; // ì´ˆê¸°ê°’ (resizeCanvasì—ì„œ ë™ì ìœ¼ë¡œ ì¬ê³„ì‚°ë¨)

            // --- ê²Œì„ ìƒíƒœ ---
            let board = [];
            let isGameOver = false;
            let isFirstClick = true;
            let flagsRemaining = MINE_COUNT;
            let isFlagMode = false; 
            
            // --- ìƒ‰ìƒ ì •ì˜ ---
            const COLORS = {
                BACKGROUND: '#1a202c',
                UNREVEALED: '#4a5568', 
                REVEALED: '#2d3748', 
                BORDER: '#1a202c', 
                MINE: '#e53e3e', 
                FLAG: '#63b3ed', 
                TEXT: '#edf2f7',
                NUMBERS: [
                    'transparent', '#63b3ed', '#48bb78', '#fc8181', '#a3bffa', '#ecc94b', '#f6ad55', '#e53e3e', '#718096'
                ]
            };

            // --- í—¬í¼ í•¨ìˆ˜ ---

            // 1. ìœ¡ê°í˜• ì¢Œí‘œ ê³„ì‚° (Pointy Top Hex)
            const getHexagonPoints = (center_x, center_y, size) => {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle_deg = 30 + 60 * i;
                    const angle_rad = Math.PI / 180 * angle_deg;
                    points.push({
                        x: center_x + size * Math.cos(angle_rad),
                        y: center_y + size * Math.sin(angle_rad)
                    });
                }
                return points;
            };

            // 2. Grid (row, col)ì„ Pixel (x, y)ë¡œ ë³€í™˜
            const hexToPixel = (row, col) => {
                const w = Math.sqrt(3) * HEX_SIZE; 
                const h = 2 * HEX_SIZE; 
                
                let x = w * (col + 0.5 * (row % 2));
                let y = h * 0.75 * row;

                return {
                    x: x + w / 2 + MARGIN,
                    y: y + HEX_SIZE + MARGIN 
                };
            };
            
            // 3. Pixel (x, y)ë¥¼ Grid (row, col)ë¡œ ë³€í™˜
            const pixelToHex = (px, py) => {
                px -= MARGIN;
                py -= MARGIN;
                
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                const h_step = h * 0.75; 

                let r_approx = Math.round((py - HEX_SIZE) / h_step);
                let x_adjusted = px - w / 2;
                if (r_approx % 2 === 1) {
                    x_adjusted -= w / 2;
                }
                let q_approx = Math.round(x_adjusted / w);
                
                let bestRow = -1, bestCol = -1;
                let minDistance = Infinity;

                for (let r = r_approx - 1; r <= r_approx + 1; r++) {
                    for (let c = q_approx - 1; c <= q_approx + 1; c++) {
                        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                            const center = hexToPixel(r, c);
                            const dx = (px + MARGIN) - center.x;
                            const dy = (py + MARGIN) - center.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < minDistance) {
                                minDistance = distance;
                                bestRow = r;
                                bestCol = c;
                            }
                        }
                    }
                }
                
                if (minDistance <= HEX_SIZE * 0.95 && bestRow !== -1) {
                    return { row: bestRow, col: bestCol };
                }

                return null;
            };

            // 4. ìœ¡ê°í˜• ì´ì›ƒ ì°¾ê¸° (Pointy Top, Row-Staggered Logic)
            const getNeighbors = (r, c) => {
                const neighbors = [];
                const isOddRow = r % 2 !== 0; 

                const offsets = [
                    [0, -1], [0, 1], 
                    [-1, 0], [1, 0],
                ];

                if (isOddRow) {
                    offsets.push([-1, 1], [1, 1]); 
                } else {
                    offsets.push([-1, -1], [1, -1]); 
                }

                offsets.forEach(([dr, dc]) => {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        neighbors.push([nr, nc]);
                    }
                });
                return neighbors;
            };

            // 5. ìº”ë²„ìŠ¤ í”½ì…€ í¬ê¸° ì„¤ì • (í˜„ì¬ HEX_SIZE ê¸°ë°˜)
            const initializeCanvasDimensions = () => {
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                
                // ë³´ë“œì˜ í”½ì…€ ë„ˆë¹„/ë†’ì´ ê³„ì‚°
                const max_x = w * COLS + w / 2;
                const max_y = h * 0.75 * (ROWS - 1) + h;
                
                // ìº”ë²„ìŠ¤ í¬ê¸° = ë³´ë“œ í¬ê¸° + ì—¬ë°± * 2
                canvas.width = max_x + MARGIN * 2;
                canvas.height = max_y + MARGIN * 2;
            };

            // --- ê²Œì„ ë¡œì§ (ì´ì „ ìš”ì²­ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€) ---

            const createBoard = () => {
                board = Array.from({ length: ROWS }, (_, r) =>
                    Array.from({ length: COLS }, (_, c) => ({
                        row: r,
                        col: c,
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        mineCount: 0,
                    }))
                );
                flagsRemaining = MINE_COUNT;
                updateMessage();
                isGameOver = false;
                isFirstClick = true;
            };

            const placeMines = (startRow, startCol) => {
                let minesPlaced = 0;
                while (minesPlaced < MINE_COUNT) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);

                    const isStartCell = r === startRow && c === startCol;
                    const isNeighbor = getNeighbors(startRow, startCol).some(([nr, nc]) => nr === r && nc === c);

                    if (!board[r][c].isMine && !isStartCell && !isNeighbor) {
                        board[r][c].isMine = true;
                        minesPlaced++;
                    }
                }
                calculateMineCounts();
            };

            const calculateMineCounts = () => {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (!board[r][c].isMine) {
                            let count = 0;
                            getNeighbors(r, c).forEach(([nr, nc]) => {
                                if (board[nr]?.[nc]?.isMine) {
                                    count++;
                                }
                            });
                            board[r][c].mineCount = count;
                        }
                    }
                }
            };
            
            const revealCell = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS || board[r][c].isRevealed || board[r][c].isFlagged) {
                    return;
                }

                const cell = board[r][c];
                cell.isRevealed = true;

                if (cell.isMine) {
                    gameOver(false); 
                    return;
                }

                if (cell.mineCount === 0) {
                    getNeighbors(r, c).forEach(([nr, nc]) => {
                        if (!board[nr][nc].isRevealed && !board[nr][nc].isFlagged) {
                            if (board[nr][nc].mineCount === 0) {
                                revealCell(nr, nc); 
                            } else if (board[nr][nc].mineCount > 0) {
                                board[nr][nc].isRevealed = true; 
                            }
                        }
                    });
                }
                
                checkWin();
            };

            const toggleFlag = (r, c) => {
                const cell = board[r][c];
                if (cell.isRevealed) return;

                if (cell.isFlagged) {
                    cell.isFlagged = false;
                    flagsRemaining++;
                } else if (flagsRemaining > 0) {
                    cell.isFlagged = true;
                    flagsRemaining--;
                }
                updateMessage();
                checkWin();
            };

            const checkWin = () => {
                let unrevealedCount = 0;
                
                board.forEach(row => {
                    row.forEach(cell => {
                        if (!cell.isRevealed) {
                            unrevealedCount++;
                        }
                    });
                });

                if (unrevealedCount === MINE_COUNT && !isGameOver) {
                     gameOver(true);
                }
            };
            
            const gameOver = (isWin) => {
                isGameOver = true;
                
                if (isWin) {
                    messageBox.textContent = "ğŸ¥³ ìŠ¹ë¦¬! ë‹¤ì‹œ í•˜ì‹œê² ì–´ìš”?";
                    messageBox.style.backgroundColor = '#48bb78'; 
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isFlagged = true;
                    }));
                } else {
                    messageBox.textContent = "ğŸ’¥ ê²Œì„ ì˜¤ë²„! ì§€ë¢° í­ë°œ!";
                    messageBox.style.backgroundColor = '#e53e3e'; 
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isRevealed = true;
                    }));
                }
                drawBoard();
            };

            const updateMessage = () => {
                if (!isGameOver) {
                    messageBox.textContent = `ğŸš© ${flagsRemaining}ê°œ ë‚¨ìŒ`;
                    messageBox.style.backgroundColor = '#4a5568';
                }
            };

            // --- ë Œë”ë§ ---

            // 1. ìœ¡ê°í˜• ê·¸ë¦¬ê¸° (ê²½ê³„ì„  í¬í•¨)
            const drawHexagon = (center_x, center_y, size, fill_color, border_color) => {
                const points = getHexagonPoints(center_x, center_y, size);
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();

                ctx.fillStyle = fill_color;
                ctx.fill();

                ctx.strokeStyle = border_color; 
                ctx.lineWidth = 1;
                ctx.stroke();
            };

            // 2. ë³´ë“œ ì „ì²´ ê·¸ë¦¬ê¸°
            const drawBoard = () => {
                ctx.fillStyle = COLORS.BACKGROUND;
                ctx.fillRect(0, 0, canvas.width, canvas.height); 

                board.forEach(row => {
                    row.forEach(cell => {
                        const { x, y } = hexToPixel(cell.row, cell.col);
                        
                        let fillColor, contentColor, content = '';

                        if (cell.isRevealed) {
                            fillColor = COLORS.REVEALED;
                            contentColor = COLORS.TEXT;

                            if (cell.isMine) {
                                fillColor = COLORS.MINE;
                                content = 'ğŸ’£';
                            } else if (cell.mineCount > 0) {
                                content = cell.mineCount.toString();
                                contentColor = COLORS.NUMBERS[cell.mineCount];
                            } else {
                                fillColor = COLORS.REVEALED;
                            }
                        } else {
                            fillColor = COLORS.UNREVEALED;
                            
                            if (cell.isFlagged) {
                                content = 'ğŸš©';
                                contentColor = COLORS.FLAG;
                            }
                        }

                        drawHexagon(x, y, HEX_SIZE, fillColor, COLORS.BORDER);
                        
                        if (content) {
                            ctx.fillStyle = contentColor;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            if (content.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/)) {
                                ctx.font = `bold ${HEX_SIZE * 0.9}px Noto Sans KR`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            } else {
                                ctx.font = `bold ${HEX_SIZE * 1.1}px Roboto Mono`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            }
                        }
                    });
                });
            };

            // --- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

            const handleCanvasClick = (event) => {
                if (event.type === 'contextmenu') {
                    event.preventDefault();
                    return;
                }
                
                if (isGameOver) return;

                const rect = canvas.getBoundingClientRect();
                // ìº”ë²„ìŠ¤ í”½ì…€ í¬ê¸° / CSS ë Œë”ë§ í¬ê¸°ë¡œ ìŠ¤ì¼€ì¼ë§ ë¹„ìœ¨ ê³„ì‚°
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height; 
                const px = (event.clientX - rect.left) * scaleX;
                const py = (event.clientY - rect.top) * scaleY;
                
                const hex = pixelToHex(px, py);
                if (!hex) return;
                
                const { row, col } = hex;

                if (isFirstClick) {
                    placeMines(row, col);
                    isFirstClick = false;
                }

                const isFlagAction = (event.button === 2) || isFlagMode;
                
                if (isFlagAction) {
                    toggleFlag(row, col);
                } else {
                    if (board[row][col].isFlagged) {
                        return;
                    }
                    revealCell(row, col);
                }

                drawBoard();
            };
            
            flagToggleButton.addEventListener('click', () => {
                isFlagMode = !isFlagMode;
                flagToggleButton.textContent = isFlagMode ? "âŒ ê¹ƒë°œ ëª¨ë“œ í•´ì œ" : "ğŸš© ê¹ƒë°œ ëª¨ë“œ";
                flagToggleButton.classList.toggle('active', isFlagMode);
                if (isFlagMode) {
                    messageBox.textContent = "ê¹ƒë°œì„ ê½‚ì„ ì…€ì„ í„°ì¹˜í•˜ì„¸ìš”.";
                } else {
                    updateMessage();
                }
            });

            resetButton.addEventListener('click', () => {
                isFlagMode = false;
                flagToggleButton.textContent = "ğŸš© ì¼ë°˜ ëª¨ë“œ";
                flagToggleButton.classList.remove('active');
                startGame();
            });

            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (PC)
            canvas.addEventListener('mousedown', handleCanvasClick);
            canvas.addEventListener('contextmenu', handleCanvasClick); 

            // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                handleCanvasClick({
                    clientX: e.touches[0].clientX,
                    clientY: e.touches[0].clientY,
                    target: e.target,
                    preventDefault: () => e.preventDefault(),
                    button: 0, 
                    type: 'mousedown'
                });
            });

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬ (ë°˜ì‘í˜• ìº”ë²„ìŠ¤)
            const resizeCanvas = () => {
                const w_factor = Math.sqrt(3);
                const h_step = 1.5;

                // 1. ë³´ë“œ í¬ê¸°ì˜ ë‹¨ìœ„ ê³„ì‚° (HEX_SIZEê°€ 1ì´ë¼ê³  ê°€ì •)
                const boardWidthUnits = w_factor * COLS + w_factor / 2;
                const boardHeightUnits = h_step * ROWS + 0.5;

                // 2. ìº”ë²„ìŠ¤ê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê³µê°„ (ì»¨íŠ¸ë¡¤ ì˜ì—­ ì œì™¸)
                const availableWidth = gameArea.clientWidth - MARGIN * 2;
                const availableHeight = gameArea.clientHeight - MARGIN * 2;
                
                if (availableWidth <= 0 || availableHeight <= 0) return;

                // 3. ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ ì¤‘ ë” ë¹¡ë¹¡í•œ ë¹„ìœ¨ì— ë§ì¶° HEX_SIZE ê³„ì‚°
                const hexSizeFromWidth = availableWidth / boardWidthUnits;
                const hexSizeFromHeight = availableHeight / boardHeightUnits;
                
                // ë‘˜ ì¤‘ ì‘ì€ ê°’ì„ ì„ íƒí•˜ì—¬ ë³´ë“œê°€ ì˜ë¦¬ì§€ ì•Šë„ë¡ í•¨
                const newHexSize = Math.floor(Math.min(hexSizeFromWidth, hexSizeFromHeight));

                // 4. HEX_SIZE í´ë¨í”„ (ìµœì†Œ 8px, ìµœëŒ€ 30px)
                HEX_SIZE = Math.max(8, Math.min(30, newHexSize));
                
                // 5. ìº”ë²„ìŠ¤ í”½ì…€ í¬ê¸° ì¬ì„¤ì •
                initializeCanvasDimensions();
                
                // 6. CSS ë†’ì´ ì¡°ì ˆ (width: 100%ëŠ” CSSê°€ ì²˜ë¦¬í•˜ê³ , ë†’ì´ëŠ” í”½ì…€ í¬ê¸°ì— ë§ì¶° ì¡°ì •)
                // ìº”ë²„ìŠ¤ì˜ ê³ ìœ í•œ ì¢…íš¡ë¹„ë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•´ CSS heightë¥¼ ì¡°ì •
                canvas.style.height = `${canvas.height}px`; 
                
                // ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                drawBoard();
            };
            
            // --- ì‹œì‘ í•¨ìˆ˜ ---
            const startGame = () => {
                createBoard();
                // ìº”ë²„ìŠ¤ í¬ê¸°(HEX_SIZE)ëŠ” resizeCanvasì—ì„œ ê²°ì •ë©ë‹ˆë‹¤.
                resizeCanvas(); 
                updateMessage();
            };

            // ì´ˆê¸° ì‹œì‘ ë° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ì—°ê²°
            window.addEventListener('resize', resizeCanvas);
            
            // ê²Œì„ ì‹œì‘ (DOMì´ ë¡œë“œëœ í›„ resizeCanvasë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ˆê¸° í¬ê¸°ë¥¼ ê²°ì •)
            startGame();
        });
    </script>
</body>
</html>