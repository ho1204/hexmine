<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ¡ê°í˜• ì§€ë¢°ì°¾ê¸° (18x14, ì§€ë¢° 55ê°œ)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* ì‚¬ìš©ì ì •ì˜ CSS: ëª¨ë°”ì¼ ì„¸ë¡œ í™”ë©´ì— ìµœì í™” ë° í™”ë©´ ê°€ë“ ì±„ìš°ê¸° */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a202c; /* ë‹¤í¬ ëª¨ë“œ ë°°ê²½ */
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh; 
            margin: 0;
            padding: 0; 
            box-sizing: border-box;
            width: 100vw;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            border-radius: 0; 
            box-shadow: none; 
            padding: 1rem;
            width: 100%; 
            height: 100vh; 
            max-width: 500px; /* ì„¸ë¡œ í™”ë©´ ìµœëŒ€ ë„ˆë¹„ ì œí•œ */
            overflow: hidden; 
        }
        
        #game-area {
            width: 100%;
            flex-grow: 1; /* ë‚¨ì€ ìˆ˜ì§ ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ */
            display: flex;
            justify-content: center;
            align-items: center;
            padding-bottom: 5px;
            overflow: hidden; 
        }

        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0.75rem;
            padding: 0 0.25rem;
            flex-wrap: nowrap; 
            gap: 0.5rem; /* ë²„íŠ¼ê³¼ ë©”ì‹œì§€ ë°•ìŠ¤ ì‚¬ì´ì˜ ê°„ê²© */
        }

        #message-box {
            background-color: #4a5568;
            color: #edf2f7;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            /* ë©”ì‹œì§€ ë°•ìŠ¤ê°€ ë‚¨ì€ ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€í•˜ë„ë¡ ì„¤ì • */
            flex: 1 1 0%; 
            min-width: 0; 
        }
        
        #game-canvas {
            background-color: #1a202c; 
            border-radius: 0.5rem;
            touch-action: none; 
            cursor: pointer;
            max-width: 100%;
            max-height: 100%;
            display: block; 
        }

        .btn-action {
            padding: 0.75rem 1.5rem;
            background-color: #48bb78; 
            color: white;
            border-radius: 0.75rem;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn-action:hover {
            background-color: #38a169;
        }
        
        .btn-action:active {
            transform: scale(0.98);
        }

        .mono-font {
            font-family: 'Roboto Mono', monospace;
        }

        .flag-toggle-btn {
            background-color: #63b3ed;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
            /* **ìˆ˜ì •:** ë²„íŠ¼ì˜ ë„ˆë¹„ë¥¼ ê°€ì¥ ê¸´ í…ìŠ¤íŠ¸("âŒ ê¹ƒë°œ ëª¨ë“œ í•´ì œ")ì— ë§ì¶° ê³ ì • */
            flex: 0 0 170px;
            min-width: 170px;
            text-wrap: nowrap; 
        }
        .flag-toggle-btn:hover {
            background-color: #4299e1;
        }
        .flag-toggle-btn.active {
            background-color: #e53e3e;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 class="text-2xl font-bold mb-3 text-white">Hex ì§€ë¢°ì°¾ê¸° (18x14)</h1>
        
        <div id="controls">
            <div id="message-box" class="mono-font">ì§€ë¢° 55ê°œ</div>
            <button id="flag-toggle" class="flag-toggle-btn">
                ğŸš© ì¼ë°˜ ëª¨ë“œ
            </button>
        </div>
        
        <div id="game-area">
            <canvas id="game-canvas"></canvas>
        </div>

        <button id="reset-button" class="btn-action w-full mt-3">
            ìƒˆ ê²Œì„ ì‹œì‘
        </button>
        
        <p class="text-xs text-gray-400 mt-2">
            **ëª¨ë°”ì¼:** í„°ì¹˜í•˜ì—¬ ì—´ê¸°/ê¹ƒë°œ ê½‚ê¸° (ëª¨ë“œ ì „í™˜).
        </p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const resetButton = document.getElementById('reset-button');
            const messageBox = document.getElementById('message-box');
            const flagToggleButton = document.getElementById('flag-toggle');
            const gameArea = document.getElementById('game-area');
            
            // --- ê²Œì„ ì„¤ì • (18x14, 55 ì§€ë¢° (22%)) ---
            const ROWS = 18; // ì„¸ë¡œ 18ì¹¸
            const COLS = 14; // ê°€ë¡œ 14ì¹¸
            const TOTAL_CELLS = ROWS * COLS; // 252
            const MINE_COUNT = 55; // Math.floor(TOTAL_CELLS * 0.22); // 55
            const MARGIN = 4; 
            
            // --- ë™ì  í¬ê¸° ë³€ìˆ˜ ---
            let HEX_SIZE = 20; 

            // --- ê²Œì„ ìƒíƒœ ---
            let board = [];
            let isGameOver = false;
            let isFirstClick = true;
            let flagsRemaining = MINE_COUNT;
            let isFlagMode = false; 
            
            // --- ìƒ‰ìƒ ì •ì˜ ---
            const COLORS = {
                BACKGROUND: '#1a202c',
                UNREVEALED: '#4a5568', 
                REVEALED: '#2d3748', 
                BORDER: '#1a202c', 
                MINE: '#e53e3e', 
                FLAG: '#63b3ed', 
                TEXT: '#edf2f7',
                NUMBERS: [
                    'transparent', '#63b3ed', '#48bb78', '#fc8181', '#a3bffa', '#ecc94b', '#f6ad55', '#e53e3e', '#718096'
                ]
            };

            // --- í—¬í¼ í•¨ìˆ˜ ---

            // ìœ¡ê°í˜• ì¢Œí‘œ ê³„ì‚° (Pointy Top Hex: 30ë„ íšŒì „ ì‹œì‘)
            const getHexagonPoints = (center_x, center_y, size) => {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle_deg = 30 + 60 * i;
                    const angle_rad = Math.PI / 180 * angle_deg;
                    points.push({
                        x: center_x + size * Math.cos(angle_rad),
                        y: center_y + size * Math.sin(angle_rad)
                    });
                }
                return points;
            };

            // Grid (row, col)ì„ Pixel (x, y)ë¡œ ë³€í™˜
            const hexToPixel = (row, col) => {
                const w = Math.sqrt(3) * HEX_SIZE; 
                const h = 2 * HEX_SIZE; 
                
                let x = w * (col + 0.5 * (row % 2));
                let y = h * 0.75 * row;

                return {
                    x: x + w / 2 + MARGIN,
                    y: y + HEX_SIZE + MARGIN 
                };
            };
            
            // Pixel (x, y)ë¥¼ Grid (row, col)ë¡œ ë³€í™˜
            const pixelToHex = (px, py) => {
                px -= MARGIN;
                py -= MARGIN;
                
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                const h_step = h * 0.75; 

                let r_approx = Math.round((py - HEX_SIZE) / h_step);
                let x_adjusted = px - w / 2;
                if (r_approx % 2 === 1) {
                    x_adjusted -= w / 2;
                }
                let q_approx = Math.round(x_adjusted / w);
                
                let bestRow = -1, bestCol = -1;
                let minDistance = Infinity;

                for (let r = r_approx - 1; r <= r_approx + 1; r++) {
                    for (let c = q_approx - 1; c <= q_approx + 1; c++) {
                        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                            const center = hexToPixel(r, c);
                            const dx = (px + MARGIN) - center.x;
                            const dy = (py + MARGIN) - center.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < minDistance) {
                                minDistance = distance;
                                bestRow = r;
                                bestCol = c;
                            }
                        }
                    }
                }
                
                if (minDistance <= HEX_SIZE * 0.95 && bestRow !== -1) {
                    return { row: bestRow, col: bestCol };
                }

                return null;
            };

            // ìœ¡ê°í˜• ì´ì›ƒ ì°¾ê¸° (Pointy Top, Row-Staggered Logic)
            const getNeighbors = (r, c) => {
                const neighbors = [];
                const isOddRow = r % 2 !== 0; 

                const offsets = [
                    [0, -1], [0, 1], 
                    [-1, 0], [1, 0],
                ];

                if (isOddRow) {
                    // í™€ìˆ˜ í–‰ì€ ì˜¤ë¥¸ìª½ ìœ„/ì•„ë˜ ì¶”ê°€
                    offsets.push([-1, 1], [1, 1]); 
                } else {
                    // ì§ìˆ˜ í–‰ì€ ì™¼ìª½ ìœ„/ì•„ë˜ ì¶”ê°€
                    offsets.push([-1, -1], [1, -1]); 
                }

                offsets.forEach(([dr, dc]) => {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        neighbors.push([nr, nc]);
                    }
                });
                return neighbors;
            };

            // ìº”ë²„ìŠ¤ í”½ì…€ í¬ê¸° ì„¤ì • (í˜„ì¬ HEX_SIZE ê¸°ë°˜)
            const initializeCanvasDimensions = () => {
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                
                // ë³´ë“œ í”½ì…€ í¬ê¸° ê³„ì‚°
                const max_x = w * COLS + w / 2;
                const max_y = h * 0.75 * (ROWS - 1) + h;
                
                // ìº”ë²„ìŠ¤ í¬ê¸° = ë³´ë“œ í¬ê¸° + ì—¬ë°± * 2
                canvas.width = max_x + MARGIN * 2;
                canvas.height = max_y + MARGIN * 2;
            };

            // --- ê²Œì„ ë¡œì§ ---
            
            const createBoard = () => {
                board = Array.from({ length: ROWS }, (_, r) =>
                    Array.from({ length: COLS }, (_, c) => ({
                        row: r,
                        col: c,
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        mineCount: 0,
                    }))
                );
                flagsRemaining = MINE_COUNT;
                updateMessage();
                isGameOver = false;
                isFirstClick = true;
            };

            const placeMines = (startRow, startCol) => {
                let minesPlaced = 0;
                while (minesPlaced < MINE_COUNT) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);

                    // ì²« í´ë¦­ ì…€ê³¼ ê·¸ ì£¼ë³€ 6ì¹¸ì—ëŠ” ì§€ë¢°ë¥¼ ë†“ì§€ ì•ŠìŠµë‹ˆë‹¤.
                    const isStartCell = r === startRow && c === startCol;
                    const isNeighbor = getNeighbors(startRow, startCol).some(([nr, nc]) => nr === r && nc === c);

                    if (!board[r][c].isMine && !isStartCell && !isNeighbor) {
                        board[r][c].isMine = true;
                        minesPlaced++;
                    }
                }
                calculateMineCounts();
            };

            const calculateMineCounts = () => {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (!board[r][c].isMine) {
                            let count = 0;
                            getNeighbors(r, c).forEach(([nr, nc]) => {
                                if (board[nr]?.[nc]?.isMine) {
                                    count++;
                                }
                            });
                            board[r][c].mineCount = count;
                        }
                    }
                }
            };
            
            // í•µì‹¬: ì…€ì„ ì—´ê³ , 0ì´ë©´ ì£¼ë³€ì„ ìë™ ì „íŒŒ
            const revealCell = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS || board[r][c].isRevealed || board[r][c].isFlagged) {
                    return;
                }

                const cell = board[r][c];
                cell.isRevealed = true;

                if (cell.isMine) {
                    gameOver(false); 
                    return;
                }

                if (cell.mineCount === 0) {
                    // ì£¼ë³€ ì…€ ìë™ ì—´ê¸° (ì „íŒŒ)
                    getNeighbors(r, c).forEach(([nr, nc]) => {
                        // ê¹ƒë°œì´ ê½‚íˆì§€ ì•Šì€, ì•„ì§ ì—´ë¦¬ì§€ ì•Šì€ ì…€ë§Œ ì „íŒŒ
                        if (board[nr] && board[nr][nc] && !board[nr][nc].isRevealed && !board[nr][nc].isFlagged) {
                            revealCell(nr, nc); // ì¬ê·€ í˜¸ì¶œ
                        }
                    });
                }
                
                checkWin();
            };

            const toggleFlag = (r, c) => {
                const cell = board[r][c];
                if (cell.isRevealed) return;

                if (cell.isFlagged) {
                    cell.isFlagged = false;
                    flagsRemaining++;
                } else if (flagsRemaining > 0) {
                    cell.isFlagged = true;
                    flagsRemaining--;
                }
                updateMessage();
                checkWin();
            };

            const checkWin = () => {
                let nonMineUnrevealedCount = 0;
                
                board.forEach(row => {
                    row.forEach(cell => {
                        if (!cell.isMine && !cell.isRevealed) {
                            nonMineUnrevealedCount++;
                        }
                    });
                });

                if (nonMineUnrevealedCount === 0 && !isGameOver) {
                     gameOver(true);
                }
            };
            
            const gameOver = (isWin) => {
                isGameOver = true;
                
                if (isWin) {
                    messageBox.textContent = "ğŸ¥³ ìŠ¹ë¦¬! ë‹¤ì‹œ í•˜ì‹œê² ì–´ìš”?";
                    messageBox.style.backgroundColor = '#48bb78'; 
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isFlagged = true;
                    }));
                } else {
                    messageBox.textContent = "ğŸ’¥ ê²Œì„ ì˜¤ë²„! ì§€ë¢° í­ë°œ!";
                    messageBox.style.backgroundColor = '#e53e3e'; 
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isRevealed = true;
                    }));
                }
                drawBoard();
            };

            const updateMessage = () => {
                if (!isGameOver) {
                    // ê¹ƒë°œ ëª¨ë“œ ë©”ì‹œì§€ ë³€ê²½ ìš”ì²­ ë°˜ì˜ (ë‚¨ì€ ì§€ë¢° ê°¯ìˆ˜ë§Œ í‘œì‹œ)
                    messageBox.textContent = `ğŸš© ${flagsRemaining}ê°œ ë‚¨ìŒ (ì´ ${MINE_COUNT}ê°œ)`;
                    messageBox.style.backgroundColor = '#4a5568';
                }
            };

            // 3. ìë™ ì—´ê¸° (Chording) ê¸°ëŠ¥ êµ¬í˜„
            const autoRevealNeighbors = (r, c) => {
                const cell = board[r][c];
                if (!cell.isRevealed || cell.mineCount === 0) return;

                let flaggedCount = 0;
                let hasMineFlaggedIncorrectly = false; // ì˜ëª» ê½‚ì€ ê¹ƒë°œ ì²´í¬ìš©
                const neighbors = getNeighbors(r, c);
                
                // ì¸ì ‘ ì…€ ì¤‘ ê¹ƒë°œ ê°¯ìˆ˜ ì¹´ìš´íŠ¸ ë° ì˜ëª» ê½‚ì€ ê¹ƒë°œ ì²´í¬
                neighbors.forEach(([nr, nc]) => {
                    const neighborCell = board[nr][nc];
                    if (neighborCell.isFlagged) {
                        flaggedCount++;
                        if (!neighborCell.isMine) {
                            hasMineFlaggedIncorrectly = true;
                        }
                    }
                });

                // ê¹ƒë°œ ê°¯ìˆ˜ê°€ ì…€ì˜ ì§€ë¢° ê°¯ìˆ˜ì™€ ì¼ì¹˜í•˜ë©´ ìë™ ì—´ê¸° ì‹œì‘
                if (flaggedCount === cell.mineCount) {
                    if (hasMineFlaggedIncorrectly) {
                        // ë§Œì•½ ê¹ƒë°œì´ ì˜ëª» ê½‚í˜”ë‹¤ë©´, ìë™ ì—´ê¸° ì‹œ ì§€ë¢°ê°€ í„°ì§
                        neighbors.forEach(([nr, nc]) => {
                             const neighborCell = board[nr][nc];
                             if (!neighborCell.isFlagged && !neighborCell.isRevealed) {
                                 // revealCellì´ ì§€ë¢°ë¥¼ ë°œê²¬í•˜ë©´ game overë¥¼ í˜¸ì¶œí•¨
                                 revealCell(nr, nc); 
                             }
                        });
                    } else {
                        // ê¹ƒë°œì´ ëª¨ë‘ ì˜¬ë°”ë¥´ë‹¤ë©´ ì•ˆì „í•˜ê²Œ ì—´ê¸°
                        neighbors.forEach(([nr, nc]) => {
                            const neighborCell = board[nr][nc];
                            // ê¹ƒë°œì´ ê½‚íˆì§€ ì•Šì•˜ê³ , ì•„ì§ ì—´ë¦¬ì§€ ì•Šì€ ì…€ë§Œ revealCell í˜¸ì¶œ
                            if (!neighborCell.isFlagged && !neighborCell.isRevealed) {
                                revealCell(nr, nc); 
                            }
                        });
                    }
                }
            };

            // --- ë Œë”ë§ ---

            // 1. ìœ¡ê°í˜• ê·¸ë¦¬ê¸° (ê²½ê³„ì„  í¬í•¨)
            const drawHexagon = (center_x, center_y, size, fill_color, border_color) => {
                const points = getHexagonPoints(center_x, center_y, size);
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();

                ctx.fillStyle = fill_color;
                ctx.fill();

                ctx.strokeStyle = border_color; 
                ctx.lineWidth = 1;
                ctx.stroke();
            };

            // 2. ë³´ë“œ ì „ì²´ ê·¸ë¦¬ê¸°
            const drawBoard = () => {
                ctx.fillStyle = COLORS.BACKGROUND;
                ctx.fillRect(0, 0, canvas.width, canvas.height); 

                board.forEach(row => {
                    row.forEach(cell => {
                        const { x, y } = hexToPixel(cell.row, cell.col);
                        
                        let fillColor, contentColor, content = '';

                        if (cell.isRevealed) {
                            fillColor = COLORS.REVEALED;
                            contentColor = COLORS.TEXT;

                            if (cell.isMine) {
                                fillColor = COLORS.MINE;
                                content = 'ğŸ’£';
                            } else if (cell.mineCount > 0) {
                                content = cell.mineCount.toString();
                                contentColor = COLORS.NUMBERS[cell.mineCount];
                            } else {
                                fillColor = COLORS.REVEALED;
                            }
                        } else {
                            fillColor = COLORS.UNREVEALED;
                            
                            if (cell.isFlagged) {
                                content = 'ğŸš©';
                                contentColor = COLORS.FLAG;
                            }
                        }

                        drawHexagon(x, y, HEX_SIZE, fillColor, COLORS.BORDER);
                        
                        if (content) {
                            ctx.fillStyle = contentColor;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            if (content.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/)) {
                                ctx.font = `bold ${HEX_SIZE * 0.9}px Noto Sans KR`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            } else {
                                ctx.font = `bold ${HEX_SIZE * 1.1}px Roboto Mono`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            }
                        }
                    });
                });
            };

            // --- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

            const handleCanvasClick = (event) => {
                if (event.type === 'contextmenu') {
                    event.preventDefault();
                    return;
                }
                
                if (isGameOver) return;

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height; 
                const px = (event.clientX - rect.left) * scaleX;
                const py = (event.clientY - rect.top) * scaleY;
                
                const hex = pixelToHex(px, py);
                if (!hex) return;
                
                const { row, col } = hex;
                const cell = board[row][col]; // í´ë¦­í•œ ì…€ ì°¸ì¡°

                if (isFirstClick) {
                    placeMines(row, col);
                    isFirstClick = false;
                }

                const isFlagAction = (event.button === 2) || isFlagMode;
                
                if (isFlagAction) {
                    toggleFlag(row, col);
                } else {
                    if (cell.isFlagged) {
                        return;
                    }
                    
                    // Chording (ìë™ ì—´ê¸°) ê¸°ëŠ¥ ì‹¤í–‰
                    if (cell.isRevealed && cell.mineCount > 0) {
                        autoRevealNeighbors(row, col);
                    } else {
                        revealCell(row, col);
                    }
                }

                drawBoard();
            };
            
            // ê¹ƒë°œ ëª¨ë“œ í† ê¸€ ë²„íŠ¼
            flagToggleButton.addEventListener('click', () => {
                isFlagMode = !isFlagMode;
                flagToggleButton.textContent = isFlagMode ? "âŒ ê¹ƒë°œ ëª¨ë“œ í•´ì œ" : "ğŸš© ì¼ë°˜ ëª¨ë“œ";
                flagToggleButton.classList.toggle('active', isFlagMode);
                updateMessage(); // í•­ìƒ ë‚¨ì€ ê¹ƒë°œ ê°¯ìˆ˜ë¥¼ í‘œì‹œ
            });

            // ìƒˆ ê²Œì„ ë²„íŠ¼
            resetButton.addEventListener('click', () => {
                isFlagMode = false;
                flagToggleButton.textContent = "ğŸš© ì¼ë°˜ ëª¨ë“œ";
                flagToggleButton.classList.remove('active');
                startGame();
            });

            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (PC)
            canvas.addEventListener('mousedown', handleCanvasClick);
            canvas.addEventListener('contextmenu', handleCanvasClick); 

            // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                handleCanvasClick({
                    clientX: e.touches[0].clientX,
                    clientY: e.touches[0].clientY,
                    target: e.target,
                    preventDefault: () => e.preventDefault(),
                    button: 0, 
                    type: 'mousedown'
                });
            });

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬ (í™”ë©´ ê°€ë“ ì±„ìš°ê¸° ë¡œì§)
            const resizeCanvas = () => {
                const w_factor = Math.sqrt(3);
                const h_step = 1.5;

                // 1. ë³´ë“œ í¬ê¸°ì˜ ë‹¨ìœ„ ê³„ì‚° (HEX_SIZEê°€ 1ì´ë¼ê³  ê°€ì •)
                const boardWidthUnits = w_factor * COLS + w_factor / 2;
                const boardHeightUnits = h_step * (ROWS - 1) + 2; 

                // 2. ìº”ë²„ìŠ¤ê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê³µê°„ (gameAreaì˜ ì‹¤ì œ í¬ê¸°)
                const availableWidth = gameArea.clientWidth - MARGIN * 2;
                const availableHeight = gameArea.clientHeight - MARGIN * 2;
                
                if (availableWidth <= 0 || availableHeight <= 0) return;

                // 3. ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ ì¤‘ ë” ë¹¡ë¹¡í•œ ë¹„ìœ¨ì— ë§ì¶° HEX_SIZE ê³„ì‚°
                const hexSizeFromWidth = availableWidth / boardWidthUnits;
                const hexSizeFromHeight = availableHeight / boardHeightUnits;
                
                // ë‘˜ ì¤‘ ì‘ì€ ê°’ì„ ì„ íƒí•˜ì—¬ ë³´ë“œê°€ ì˜ë¦¬ì§€ ì•Šë„ë¡ í•¨
                const newHexSize = Math.floor(Math.min(hexSizeFromWidth, hexSizeFromHeight) * 100) / 100;

                // 4. HEX_SIZE ì—…ë°ì´íŠ¸ (ìµœì†Œ 8px)
                HEX_SIZE = Math.max(8, newHexSize);
                
                // 5. ìº”ë²„ìŠ¤ í”½ì…€ í¬ê¸° ì¬ì„¤ì •
                initializeCanvasDimensions();
                
                // 6. CSS í¬ê¸° ì¡°ì • (game-area ì¤‘ì•™ì— ìº”ë²„ìŠ¤ ë°°ì¹˜)
                canvas.style.width = `${canvas.width}px`;
                canvas.style.height = `${canvas.height}px`; 

                drawBoard();
            };
            
            // --- ì‹œì‘ í•¨ìˆ˜ ---
            const startGame = () => {
                createBoard();
                resizeCanvas(); 
                updateMessage();
            };

            // ì´ˆê¸° ì‹œì‘ ë° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ì—°ê²°
            window.addEventListener('resize', resizeCanvas);
            
            // gameAreaì˜ í¬ê¸°ê°€ ê²°ì •ëœ í›„ resizeCanvasë¥¼ í˜¸ì¶œ
            window.onload = function() {
                setTimeout(startGame, 100);
            }
        });
    </script>
</body>
</html>