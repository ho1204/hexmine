<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ¡ê°í˜• ì§€ë¢°ì°¾ê¸° (ì§€ë¢° 80ê°œ, 25%)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* ì‚¬ìš©ì ì •ì˜ CSS: ëª¨ë°”ì¼ ì„¸ë¡œ í™”ë©´ì— ìµœì í™” ë° í™”ë©´ ê°€ë“ ì±„ìš°ê¸° */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a202c; /* ë‹¤í¬ ëª¨ë“œ ë°°ê²½ */
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            /* í™”ë©´ ë†’ì´ë¥¼ ê±°ì˜ ì™„ì „íˆ ì‚¬ìš© */
            min-height: 100vh; 
            margin: 0;
            padding: 0; /* bodyì˜ ê¸°ë³¸ íŒ¨ë”© ì œê±° */
            box-sizing: border-box;
            width: 100vw;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2d3748;
            border-radius: 0; /* ëª¨ë°”ì¼ì—ì„œ í™”ë©´ ëê¹Œì§€ ì‚¬ìš©í•˜ê¸° ìœ„í•´ í…Œë‘ë¦¬ ì œê±° */
            box-shadow: none; 
            padding: 1rem;
            width: 100%; 
            /* í™”ë©´ ë†’ì´ë¥¼ ê°€ë“ ì±„ìš°ë˜, ë¸Œë¼ìš°ì € UIë¥¼ ê³ ë ¤í•´ ì•½ê°„ì˜ ì—¬ë°± í™•ë³´ */
            height: 100vh; 
            max-width: 500px; /* ì„¸ë¡œ í™”ë©´ ìµœëŒ€ ë„ˆë¹„ ì œí•œ */
            overflow: hidden; 
        }
        
        #game-area {
            width: 100%;
            flex-grow: 1; /* ë‚¨ì€ ìˆ˜ì§ ê³µê°„ì„ ëª¨ë‘ ì°¨ì§€ */
            display: flex;
            justify-content: center;
            align-items: center;
            padding-bottom: 5px;
            overflow: hidden; 
        }

        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0.75rem;
            padding: 0 0.25rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        #message-box {
            background-color: #4a5568;
            color: #edf2f7;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            font-size: 1rem;
            text-align: center;
            flex-grow: 1;
            min-width: 100px;
        }
        
        #game-canvas {
            background-color: #1a202c; 
            border-radius: 0.5rem;
            touch-action: none; 
            cursor: pointer;
            /* ìº”ë²„ìŠ¤ê°€ ë¶€ëª¨ ì˜ì—­(game-area)ì„ ìµœëŒ€í•œ ì±„ìš°ë„ë¡ ì„¤ì • */
            max-width: 100%;
            max-height: 100%;
            display: block; /* ì¸ë¼ì¸ ìš”ì†Œ ê³µë°± ì œê±° */
        }

        .btn-action {
            padding: 0.75rem 1.5rem;
            background-color: #48bb78; 
            color: white;
            border-radius: 0.75rem;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn-action:hover {
            background-color: #38a169;
        }
        
        .btn-action:active {
            transform: scale(0.98);
        }

        .mono-font {
            font-family: 'Roboto Mono', monospace;
        }

        .flag-toggle-btn {
            background-color: #63b3ed;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s;
            flex-grow: 1;
        }
        .flag-toggle-btn:hover {
            background-color: #4299e1;
        }
        .flag-toggle-btn.active {
            background-color: #e53e3e;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 class="text-2xl font-bold mb-3 text-white">Hex ì§€ë¢°ì°¾ê¸° (ì§€ë¢° 80ê°œ)</h1>
        
        <div id="controls">
            <div id="message-box" class="mono-font">ì§€ë¢° 80ê°œ</div>
            <button id="flag-toggle" class="flag-toggle-btn">
                ğŸš© ì¼ë°˜ ëª¨ë“œ
            </button>
        </div>
        
        <div id="game-area">
            <canvas id="game-canvas"></canvas>
        </div>

        <button id="reset-button" class="btn-action w-full mt-3">
            ìƒˆ ê²Œì„ ì‹œì‘
        </button>
        
        <p class="text-xs text-gray-400 mt-2">
            **ëª¨ë°”ì¼:** í„°ì¹˜í•˜ì—¬ ì—´ê¸°/ê¹ƒë°œ ê½‚ê¸° (ëª¨ë“œ ì „í™˜).
        </p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const resetButton = document.getElementById('reset-button');
            const messageBox = document.getElementById('message-box');
            const flagToggleButton = document.getElementById('flag-toggle');
            const gameArea = document.getElementById('game-area');
            const gameContainer = document.getElementById('game-container');
            
            // --- ê²Œì„ ì„¤ì • (20x16, 80 ì§€ë¢° (25%)) ---
            const ROWS = 20; // ì„¸ë¡œ 20ì¹¸
            const COLS = 16; // ê°€ë¡œ 16ì¹¸
            const MINE_COUNT = 80; // ì „ì²´ 320ì…€ì˜ 25%
            const MARGIN = 4; // ìº”ë²„ìŠ¤ ì£¼ë³€ ì—¬ë°±ì„ ìµœì†Œí™”
            
            // --- ë™ì  í¬ê¸° ë³€ìˆ˜ ---
            let HEX_SIZE = 20; 

            // --- ê²Œì„ ìƒíƒœ ---
            let board = [];
            let isGameOver = false;
            let isFirstClick = true;
            let flagsRemaining = MINE_COUNT;
            let isFlagMode = false; 
            
            // --- ìƒ‰ìƒ ì •ì˜ ---
            const COLORS = {
                BACKGROUND: '#1a202c',
                UNREVEALED: '#4a5568', 
                REVEALED: '#2d3748', 
                BORDER: '#1a202c', 
                MINE: '#e53e3e', 
                FLAG: '#63b3ed', 
                TEXT: '#edf2f7',
                NUMBERS: [
                    'transparent', '#63b3ed', '#48bb78', '#fc8181', '#a3bffa', '#ecc94b', '#f6ad55', '#e53e3e', '#718096'
                ]
            };

            // --- í—¬í¼ í•¨ìˆ˜ ---

            // ìœ¡ê°í˜• ì¢Œí‘œ ê³„ì‚° (Pointy Top Hex: 30ë„ íšŒì „ ì‹œì‘)
            const getHexagonPoints = (center_x, center_y, size) => {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle_deg = 30 + 60 * i;
                    const angle_rad = Math.PI / 180 * angle_deg;
                    points.push({
                        x: center_x + size * Math.cos(angle_rad),
                        y: center_y + size * Math.sin(angle_rad)
                    });
                }
                return points;
            };

            // Grid (row, col)ì„ Pixel (x, y)ë¡œ ë³€í™˜
            const hexToPixel = (row, col) => {
                const w = Math.sqrt(3) * HEX_SIZE; 
                const h = 2 * HEX_SIZE; 
                
                let x = w * (col + 0.5 * (row % 2));
                let y = h * 0.75 * row;

                return {
                    x: x + w / 2 + MARGIN,
                    y: y + HEX_SIZE + MARGIN 
                };
            };
            
            // Pixel (x, y)ë¥¼ Grid (row, col)ë¡œ ë³€í™˜
            const pixelToHex = (px, py) => {
                px -= MARGIN;
                py -= MARGIN;
                
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                const h_step = h * 0.75; 

                let r_approx = Math.round((py - HEX_SIZE) / h_step);
                let x_adjusted = px - w / 2;
                if (r_approx % 2 === 1) {
                    x_adjusted -= w / 2;
                }
                let q_approx = Math.round(x_adjusted / w);
                
                let bestRow = -1, bestCol = -1;
                let minDistance = Infinity;

                for (let r = r_approx - 1; r <= r_approx + 1; r++) {
                    for (let c = q_approx - 1; c <= q_approx + 1; c++) {
                        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                            const center = hexToPixel(r, c);
                            const dx = (px + MARGIN) - center.x;
                            const dy = (py + MARGIN) - center.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < minDistance) {
                                minDistance = distance;
                                bestRow = r;
                                bestCol = c;
                            }
                        }
                    }
                }
                
                if (minDistance <= HEX_SIZE * 0.95 && bestRow !== -1) {
                    return { row: bestRow, col: bestCol };
                }

                return null;
            };

            // ìœ¡ê°í˜• ì´ì›ƒ ì°¾ê¸° (Pointy Top, Row-Staggered Logic)
            const getNeighbors = (r, c) => {
                const neighbors = [];
                const isOddRow = r % 2 !== 0; 

                const offsets = [
                    [0, -1], [0, 1], 
                    [-1, 0], [1, 0],
                ];

                if (isOddRow) {
                    offsets.push([-1, 1], [1, 1]); 
                } else {
                    offsets.push([-1, -1], [1, -1]); 
                }

                offsets.forEach(([dr, dc]) => {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                        neighbors.push([nr, nc]);
                    }
                });
                return neighbors;
            };

            // ìº”ë²„ìŠ¤ í”½ì…€ í¬ê¸° ì„¤ì • (í˜„ì¬ HEX_SIZE ê¸°ë°˜)
            const initializeCanvasDimensions = () => {
                const w = Math.sqrt(3) * HEX_SIZE;
                const h = 2 * HEX_SIZE;
                
                // ë³´ë“œ í”½ì…€ í¬ê¸° ê³„ì‚°
                const max_x = w * COLS + w / 2;
                const max_y = h * 0.75 * (ROWS - 1) + h;
                
                // ìº”ë²„ìŠ¤ í¬ê¸° = ë³´ë“œ í¬ê¸° + ì—¬ë°± * 2
                canvas.width = max_x + MARGIN * 2;
                canvas.height = max_y + MARGIN * 2;
            };

            // --- ê²Œì„ ë¡œì§ ---
            
            const createBoard = () => {
                board = Array.from({ length: ROWS }, (_, r) =>
                    Array.from({ length: COLS }, (_, c) => ({
                        row: r,
                        col: c,
                        isMine: false,
                        isRevealed: false,
                        isFlagged: false,
                        mineCount: 0,
                    }))
                );
                flagsRemaining = MINE_COUNT;
                updateMessage();
                isGameOver = false;
                isFirstClick = true;
            };

            const placeMines = (startRow, startCol) => {
                let minesPlaced = 0;
                while (minesPlaced < MINE_COUNT) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);

                    // ì²« í´ë¦­ ì…€ê³¼ ê·¸ ì£¼ë³€ 6ì¹¸ì—ëŠ” ì§€ë¢°ë¥¼ ë†“ì§€ ì•ŠìŠµë‹ˆë‹¤.
                    const isStartCell = r === startRow && c === startCol;
                    const isNeighbor = getNeighbors(startRow, startCol).some(([nr, nc]) => nr === r && nc === c);

                    if (!board[r][c].isMine && !isStartCell && !isNeighbor) {
                        board[r][c].isMine = true;
                        minesPlaced++;
                    }
                }
                calculateMineCounts();
            };

            const calculateMineCounts = () => {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (!board[r][c].isMine) {
                            let count = 0;
                            getNeighbors(r, c).forEach(([nr, nc]) => {
                                // ë°°ì—´ ë²”ìœ„ ì²´í¬ëŠ” getNeighborsì—ì„œ í•˜ì§€ë§Œ, ì•ˆì „ì„ ìœ„í•´ ì˜µì…”ë„ ì²´ì´ë‹ ì‚¬ìš©
                                if (board[nr]?.[nc]?.isMine) {
                                    count++;
                                }
                            });
                            board[r][c].mineCount = count;
                        }
                    }
                }
            };
            
            const revealCell = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS || board[r][c].isRevealed || board[r][c].isFlagged) {
                    return;
                }

                const cell = board[r][c];
                cell.isRevealed = true;

                if (cell.isMine) {
                    gameOver(false); 
                    return;
                }

                if (cell.mineCount === 0) {
                    // ì£¼ë³€ ì…€ ìë™ ì—´ê¸°
                    getNeighbors(r, c).forEach(([nr, nc]) => {
                        if (board[nr] && board[nr][nc] && !board[nr][nc].isRevealed && !board[nr][nc].isFlagged) {
                            revealCell(nr, nc); // ì¬ê·€ í˜¸ì¶œ
                        }
                    });
                }
                
                checkWin();
            };

            const toggleFlag = (r, c) => {
                const cell = board[r][c];
                if (cell.isRevealed) return;

                if (cell.isFlagged) {
                    cell.isFlagged = false;
                    flagsRemaining++;
                } else if (flagsRemaining > 0) {
                    cell.isFlagged = true;
                    flagsRemaining--;
                }
                updateMessage();
                checkWin();
            };

            const checkWin = () => {
                let unrevealedCount = 0;
                
                board.forEach(row => {
                    row.forEach(cell => {
                        // ì§€ë¢°ê°€ ì•„ë‹Œë° ì—´ë¦¬ì§€ ì•Šì€ ì…€ì˜ ìˆ˜ë¥¼ ì„¸ëŠ” ê²ƒì´ ë” ì •í™•í•©ë‹ˆë‹¤.
                        if (!cell.isMine && !cell.isRevealed) {
                            unrevealedCount++;
                        }
                    });
                });

                // ì§€ë¢°ê°€ ì•„ë‹Œ ëª¨ë“  ì…€ì´ ì—´ë ¸ë‹¤ë©´ ìŠ¹ë¦¬ì…ë‹ˆë‹¤.
                if (unrevealedCount === 0 && !isGameOver) {
                     gameOver(true);
                }
            };
            
            const gameOver = (isWin) => {
                isGameOver = true;
                
                if (isWin) {
                    messageBox.textContent = "ğŸ¥³ ìŠ¹ë¦¬! ë‹¤ì‹œ í•˜ì‹œê² ì–´ìš”?";
                    messageBox.style.backgroundColor = '#48bb78'; 
                    // ìŠ¹ë¦¬ ì‹œ ëª¨ë“  ì§€ë¢°ì— ê¹ƒë°œ í‘œì‹œ
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isFlagged = true;
                    }));
                } else {
                    messageBox.textContent = "ğŸ’¥ ê²Œì„ ì˜¤ë²„! ì§€ë¢° í­ë°œ!";
                    messageBox.style.backgroundColor = '#e53e3e'; 
                    // íŒ¨ë°° ì‹œ ëª¨ë“  ì§€ë¢° ê³µê°œ
                    board.forEach(row => row.forEach(cell => {
                        if (cell.isMine) cell.isRevealed = true;
                    }));
                }
                drawBoard();
            };

            const updateMessage = () => {
                if (!isGameOver) {
                    messageBox.textContent = `ğŸš© ${flagsRemaining}ê°œ ë‚¨ìŒ (ì´ ${MINE_COUNT}ê°œ)`;
                    messageBox.style.backgroundColor = '#4a5568';
                }
            };


            // --- ë Œë”ë§ ---

            // 1. ìœ¡ê°í˜• ê·¸ë¦¬ê¸° (ê²½ê³„ì„  í¬í•¨)
            const drawHexagon = (center_x, center_y, size, fill_color, border_color) => {
                const points = getHexagonPoints(center_x, center_y, size);
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();

                ctx.fillStyle = fill_color;
                ctx.fill();

                ctx.strokeStyle = border_color; 
                ctx.lineWidth = 1;
                ctx.stroke();
            };

            // 2. ë³´ë“œ ì „ì²´ ê·¸ë¦¬ê¸°
            const drawBoard = () => {
                // ìº”ë²„ìŠ¤ ë°°ê²½ ì±„ìš°ê¸°
                ctx.fillStyle = COLORS.BACKGROUND;
                ctx.fillRect(0, 0, canvas.width, canvas.height); 

                board.forEach(row => {
                    row.forEach(cell => {
                        const { x, y } = hexToPixel(cell.row, cell.col);
                        
                        let fillColor, contentColor, content = '';

                        if (cell.isRevealed) {
                            fillColor = COLORS.REVEALED;
                            contentColor = COLORS.TEXT;

                            if (cell.isMine) {
                                fillColor = COLORS.MINE;
                                content = 'ğŸ’£';
                            } else if (cell.mineCount > 0) {
                                content = cell.mineCount.toString();
                                contentColor = COLORS.NUMBERS[cell.mineCount];
                            } else {
                                fillColor = COLORS.REVEALED;
                            }
                        } else {
                            fillColor = COLORS.UNREVEALED;
                            
                            if (cell.isFlagged) {
                                content = 'ğŸš©';
                                contentColor = COLORS.FLAG;
                            }
                        }

                        drawHexagon(x, y, HEX_SIZE, fillColor, COLORS.BORDER);
                        
                        if (content) {
                            ctx.fillStyle = contentColor;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            if (content.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/)) {
                                // ì´ëª¨ì§€ í°íŠ¸ í¬ê¸° ì¡°ì •
                                ctx.font = `bold ${HEX_SIZE * 0.9}px Noto Sans KR`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            } else {
                                // ìˆ«ì í°íŠ¸ í¬ê¸° ì¡°ì •
                                ctx.font = `bold ${HEX_SIZE * 1.1}px Roboto Mono`;
                                ctx.fillText(content, x, y + HEX_SIZE * 0.1); 
                            }
                        }
                    });
                });
            };

            // --- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

            const handleCanvasClick = (event) => {
                // ì˜¤ë¥¸ìª½ í´ë¦­ ë°©ì§€ (PC)
                if (event.type === 'contextmenu') {
                    event.preventDefault();
                    return;
                }
                
                if (isGameOver) return;

                // ìº”ë²„ìŠ¤ ì¢Œí‘œ ê³„ì‚°
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height; 
                const px = (event.clientX - rect.left) * scaleX;
                const py = (event.clientY - rect.top) * scaleY;
                
                const hex = pixelToHex(px, py);
                if (!hex) return;
                
                const { row, col } = hex;

                // ì²« í´ë¦­ ì‹œ ì§€ë¢° ë°°ì¹˜
                if (isFirstClick) {
                    placeMines(row, col);
                    isFirstClick = false;
                }

                // ê¹ƒë°œ ëª¨ë“œ ë˜ëŠ” ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ ë²„íŠ¼ í´ë¦­
                const isFlagAction = (event.button === 2) || isFlagMode;
                
                if (isFlagAction) {
                    toggleFlag(row, col);
                } else {
                    if (board[row][col].isFlagged) {
                        return; // ê¹ƒë°œì´ ê½‚íŒ ì…€ì€ ì—´ì§€ ì•ŠìŒ
                    }
                    revealCell(row, col);
                }

                drawBoard();
            };
            
            // ê¹ƒë°œ ëª¨ë“œ í† ê¸€ ë²„íŠ¼
            flagToggleButton.addEventListener('click', () => {
                isFlagMode = !isFlagMode;
                flagToggleButton.textContent = isFlagMode ? "âŒ ê¹ƒë°œ ëª¨ë“œ í•´ì œ" : "ğŸš© ì¼ë°˜ ëª¨ë“œ";
                flagToggleButton.classList.toggle('active', isFlagMode);
                if (isFlagMode) {
                    messageBox.textContent = "ê¹ƒë°œì„ ê½‚ì„ ì…€ì„ í„°ì¹˜í•˜ì„¸ìš”.";
                } else {
                    updateMessage();
                }
            });

            // ìƒˆ ê²Œì„ ë²„íŠ¼
            resetButton.addEventListener('click', () => {
                isFlagMode = false;
                flagToggleButton.textContent = "ğŸš© ì¼ë°˜ ëª¨ë“œ";
                flagToggleButton.classList.remove('active');
                startGame();
            });

            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (PC)
            canvas.addEventListener('mousedown', handleCanvasClick);
            canvas.addEventListener('contextmenu', handleCanvasClick); 

            // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                // í„°ì¹˜ ì¢Œí‘œë¥¼ ì´ìš©í•´ í´ë¦­ ì´ë²¤íŠ¸ ì²˜ë¦¬
                handleCanvasClick({
                    clientX: e.touches[0].clientX,
                    clientY: e.touches[0].clientY,
                    target: e.target,
                    preventDefault: () => e.preventDefault(),
                    button: 0, 
                    type: 'mousedown'
                });
            });

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬ (í™”ë©´ ê°€ë“ ì±„ìš°ê¸° ë¡œì§)
            const resizeCanvas = () => {
                const w_factor = Math.sqrt(3);
                const h_step = 1.5;

                // 1. ë³´ë“œ í¬ê¸°ì˜ ë‹¨ìœ„ ê³„ì‚° (HEX_SIZEê°€ 1ì´ë¼ê³  ê°€ì •)
                const boardWidthUnits = w_factor * COLS + w_factor / 2;
                const boardHeightUnits = h_step * (ROWS - 1) + 2; 

                // 2. ìº”ë²„ìŠ¤ê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê³µê°„ (gameAreaì˜ ì‹¤ì œ í¬ê¸°)
                const availableWidth = gameArea.clientWidth - MARGIN * 2;
                const availableHeight = gameArea.clientHeight - MARGIN * 2;
                
                if (availableWidth <= 0 || availableHeight <= 0) return;

                // 3. ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ ì¤‘ ë” ë¹¡ë¹¡í•œ ë¹„ìœ¨ì— ë§ì¶° HEX_SIZE ê³„ì‚°
                const hexSizeFromWidth = availableWidth / boardWidthUnits;
                const hexSizeFromHeight = availableHeight / boardHeightUnits;
                
                // ë‘˜ ì¤‘ ì‘ì€ ê°’ì„ ì„ íƒí•˜ì—¬ ë³´ë“œê°€ ì˜ë¦¬ì§€ ì•Šë„ë¡ í•¨
                // ì†Œìˆ˜ì  ì…‹ì§¸ ìë¦¬ì—ì„œ ë°˜ì˜¬ë¦¼í•˜ì—¬ ë” ì •ë°€í•˜ê²Œ ê³„ì‚°
                const newHexSize = Math.floor(Math.min(hexSizeFromWidth, hexSizeFromHeight) * 100) / 100;

                // 4. HEX_SIZE ì—…ë°ì´íŠ¸ (ìµœì†Œ 8px)
                HEX_SIZE = Math.max(8, newHexSize);
                
                // 5. ìº”ë²„ìŠ¤ í”½ì…€ í¬ê¸° ì¬ì„¤ì •
                initializeCanvasDimensions();
                
                // 6. CSS í¬ê¸° ì¡°ì • (game-area ì¤‘ì•™ì— ìº”ë²„ìŠ¤ ë°°ì¹˜)
                canvas.style.width = `${canvas.width}px`;
                canvas.style.height = `${canvas.height}px`; 

                drawBoard();
            };
            
            // --- ì‹œì‘ í•¨ìˆ˜ ---
            const startGame = () => {
                createBoard();
                // ìº”ë²„ìŠ¤ì˜ í¬ê¸°ë¥¼ ê²°ì •í•˜ê¸° ìœ„í•´ resizeCanvas í˜¸ì¶œ
                resizeCanvas(); 
                updateMessage();
            };

            // ì´ˆê¸° ì‹œì‘ ë° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ì—°ê²°
            window.addEventListener('resize', resizeCanvas);
            
            // gameAreaì˜ í¬ê¸°ê°€ ê²°ì •ëœ í›„ resizeCanvasë¥¼ í˜¸ì¶œ
            // 100ms ì§€ì—°ì„ ì£¼ì–´ DOM ë° ë ˆì´ì•„ì›ƒ ê³„ì‚° ì‹œê°„ì„ í™•ë³´ (ëª¨ë°”ì¼ í™˜ê²½ ëŒ€ì‘)
            window.onload = function() {
                setTimeout(startGame, 100);
            }
        });
    </script>
</body>
</html>